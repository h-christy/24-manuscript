{
  "hash": "a3ab9e3256af544c1eb0d8351b3443b9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Spatial Pattern of Electric Vehicle Population in State of Washington\"\nsubtitle: \"DSAN 6750 / PPOL 6805: GIS for Spatial Data Science\"\nauthors:\n  - name: Christy Hsu\n    affiliation: Georgetown University\n    roles: writing\n    corresponding: true\ndf-print: kable\nbibliography: GIS_Manuscript.bib\ntitle-block-banner: \"#E69F0095\"\ntitle-block-banner-color: \"black\"\nformat:\n  html:\n    df-print: kable\n    # embed-resources: true\n  pdf:\n    # https://quarto.org/docs/reference/formats/pdf.html\n    link-citations: true\nprefer-html: true\n---\n\n\n\n\n\n\n## Intro\n\nThis project attempts to provide insights into the spatial pattern of EV adoptionusing approaches from spatial data science.\n\nThe Electric Vehicle Population Data provided by Washington State Department of Licensing is the main dataset used in this project.[@ElectricVehiclePopulation]\n\nTwo main sections in this project cover:\n\nInitial Evidence\n\n- Visualization\n- Global Moran's I\n- Local Moran's I\n\nHypothesis Testing\n\n- Intensity Function\n- Relative Intensity Surface\n- Monte Carlo Simulation\n\n\n### Set up\n\n#### packages\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nlibrary(tidyverse) |> suppressPackageStartupMessages()\nlibrary(sf) |> suppressPackageStartupMessages()\nlibrary(mapview) |> suppressPackageStartupMessages()\nlibrary(spatstat) |> suppressPackageStartupMessages()\nlibrary(viridis) |> suppressPackageStartupMessages()\nlibrary(spatialreg) |> suppressPackageStartupMessages()\nlibrary(spdep) |> suppressPackageStartupMessages()\nlibrary(evd) |> suppressPackageStartupMessages()\nlibrary(Pareto) |> suppressPackageStartupMessages()\nlibrary(raster) |> suppressPackageStartupMessages()\nlibrary(fields) |> suppressPackageStartupMessages()\nlibrary(scales) |> suppressPackageStartupMessages()\nlibrary(gmodels) |> suppressPackageStartupMessages()\ncb_palette <- c(\n  \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\",\"#0072B2\", \"#D55E00\", \"#CC79A7\"\n)\n```\n:::\n\n\n\n\n\n\n#### loading files\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nev_fpath <- 'data/ev1203.gpkg'\nwa_poly_fpath <- 'data/wa_poly.gpkg'\nurban_fpath <- 'data/urban_shape.gpkg'\nstation_fpath <- 'data/stations.gpkg'\nfips_fpath <- 'data/ct1202.csv'\nctsf_fpath <- 'data/ct1202.gpkg'\nev_fpath7 <- 'data/ev1202-3.gpkg'\nzcta_fpath <- 'data/zcta-tl.gpkg'\n\ngpw_pt_fpath <- 'data/gpw-pts-popcount.csv'\ngpw_pop_fpath <- 'data/gpw-popcount.tif'\nnov_ev_fpath <- 'data/nov-ev.gpkg'\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nev_sf <- sf::st_read(ev_fpath)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ev1203' from data source \n  `/Users/toyuan/24-manuscript/data/ev1203.gpkg' using driver `GPKG'\nSimple feature collection with 208002 features and 25 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -124.6274 ymin: 45.596 xmax: -117.0455 ymax: 48.99205\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nfips_df <- read_csv(fips_fpath)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nRows: 1784 Columns: 20\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (7): COUNTYFP20, TRACTCE20, NAMELSAD20, MTFCC20, FUNCSTAT20, house_medi...\ndbl (13): STATEFP20, fips, NAME20, ALAND20, AWATER20, INTPTLAT20, INTPTLON20...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nwa_poly <- sf::st_read(wa_poly_fpath)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `wa_poly' from data source \n  `/Users/toyuan/24-manuscript/data/wa_poly.gpkg' using driver `GPKG'\nSimple feature collection with 1 feature and 14 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -124.849 ymin: 45.54354 xmax: -116.9161 ymax: 49.00244\nGeodetic CRS:  NAD83\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nurban_poly <- sf::st_read(urban_fpath)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `urban_shape' from data source \n  `/Users/toyuan/24-manuscript/data/urban_shape.gpkg' using driver `GPKG'\nSimple feature collection with 56 features and 12 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.1802 ymin: 45.78668 xmax: -117.0418 ymax: 49.0021\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nstation_sf <- sf::st_read(station_fpath)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `stations' from data source \n  `/Users/toyuan/24-manuscript/data/stations.gpkg' using driver `GPKG'\nSimple feature collection with 2800 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -124.6629 ymin: 25.91606 xmax: -73.98274 ymax: 48.99526\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nct_sf <- sf::st_read(ctsf_fpath)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ct1202' from data source \n  `/Users/toyuan/24-manuscript/data/ct1202.gpkg' using driver `GPKG'\nSimple feature collection with 1784 features and 19 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.849 ymin: 45.54354 xmax: -116.9161 ymax: 49.00244\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nev_sf7 <- sf::st_read(ev_fpath7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ev1202-3' from data source \n  `/Users/toyuan/24-manuscript/data/ev1202-3.gpkg' using driver `GPKG'\nSimple feature collection with 208002 features and 24 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -124.6274 ymin: 45.596 xmax: -117.0455 ymax: 48.99205\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nzcta_sf <- sf::st_read(zcta_fpath)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `zcta-tl' from data source \n  `/Users/toyuan/24-manuscript/data/zcta-tl.gpkg' using driver `GPKG'\nSimple feature collection with 605 features and 12 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7365 ymin: 45.54354 xmax: -116.9161 ymax: 49.00244\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\ngpw_pts_df <- read_csv(gpw_pt_fpath)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nRows: 548 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): SEDAC_Tile, GPW_DataQualityInd_411_data-context_Data_Context_Descr...\ndbl  (7): ID, Latitude, Longitude, GPW_UN_Adj_PopCount_411_Line_Y_1km, GPW_U...\ndate (1): Date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\ngpw_raster <- raster(gpw_pop_fpath)\n\nnov_sf0 <- sf::st_read(nov_ev_fpath)  # 17025\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `nov-ev' from data source \n  `/Users/toyuan/24-manuscript/data/nov-ev.gpkg' using driver `GPKG'\nSimple feature collection with 17025 features and 15 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -124.6274 ymin: 30.41628 xmax: -71.06739 ymax: 48.99976\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n\n\n\n\n#### Functions\n\nfunction `to_3857` `to_4326` for CRS transform\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nto_3857 <- function(sf0){\n  tr_sf <- sf0 |> sf::st_transform(3857)\n  return(tr_sf)\n}\nto_4326 <- function(sf0){\n  tr_sf <- sf0 |> sf::st_transform(4326)\n  return(tr_sf)\n}\n```\n:::\n\n\n\n\n\n\nfunction `sf_to_ppp`^[to construct marked ppp, extra steps are needed]\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nsf_to_ppp <- function(sf0){\n  prep_sf <- sf0 |> to_3857() |> sf::st_as_sfc()\n  prep_win <- wa_poly |> to_3857() |> as.owin()\n\n  ppp0 <- as.ppp(\n    prep_sf,\n    W = prep_win\n  )\n  return(ppp0)\n}\n```\n:::\n\n\n\n\n\n\nfunction `relative_int`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nrelative_int <- function(case_ppp, contr_ppp, eps = 800) {\n\n  cases_bw <- attr(density(case_ppp), 'sigma')\n  contr_bw <- attr(density(contr_ppp), 'sigma')\n  bw0 <- (cases_bw + contr_bw) / 2\n\n  cas_int <- density(case_ppp, weights = case_ppp$marks, eps = eps, sigma = bw0)\n  contr_int <- density(contr_ppp, weights = contr_ppp$marks, eps = eps, sigma = bw0)\n\n  alphahat0 <- case_ppp$n / contr_ppp$n\n\n  x0 <- cas_int$xcol\n  y0 <- cas_int$yrow\n  rr0 <- t(cas_int$v) / t(alphahat0 * contr_int$v)\n\n  image.plot(x0, y0, rr0, asp = 1)    # main = 'title'\n}\n```\n:::\n\n\n\n\n\n\n## Initial Evidence\n\nThis exploratory section approaches EV population in WA as a point pattern, efforts are made to convince that EV adoption is interesting not only as an event but also as a spatial phenomenon. Our approaches includes: landing descriptions of our data, map visualizations and spatial autocorrelation measures.\n\n### Visualization\n\nBefore presenting our evidence of clustering in the spatial pattern of EVs, we would like to start with some clarification about the \"points\" and their locations in our data. Each observation in the dataset represents an EV with its unique DOL id. However, the longitude and latitude information corresponds to the centroid of that Zip Code Tabulation Area associated with the recorded address of the EV owner. Thus, 208,002 distinct EVs are matched to only 548 distinct points.\n\n`ev_counts`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nev_counts <- ev_sf |> group_by(location) |> summarize(count = n())\nev_counts |> nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 548\n```\n\n\n:::\n:::\n\n\n\n\n\n\nFrom the frequency table of counties, we can see that EV population exists across all counties in WA. When plotting EV count per county as a statistic, a skewed distribution gives us the first evidence of the variance in EV adoption counts across regional divisions.\n\nWith map visualization of the EV locations and counts in Washington, an impression we might have is that EV adoption as an event does not seem to be constant between locations. Furthermore, when looking at the map, we might suggest detecting clusters in specific locations and, for example, identifying these clusters with the three of the main metropolitan areas that the state overlaps.^[Seattle-Tacoma-Bellevue (WA),Portland-Vancouver-Hillsboro (OR-WA), Spokane-Spokane Valley (WA) are the three metropolitan areas listed as the top 100 populous metro areas by the Census Bureau, ranking 15th, 25th and 96th respectively][@bureauMetropolitanMicropolitanStatistical] \n\nThe Seattle-Tacoma-Bellevue Metropolitan area in the northwest; a mid-western cluster corresponding to Spokane-Spokane Valley Metropolitan area; and another approximately in Clark county, with Vancouver city to take part of the cross-states Portland-Vancouver-Hillsboro Metropolitan area.\n\n```{.r}\nurb_map <- ggplot() +\n  geom_sf(data = ct_sf, fill = \"lightgray\", color = \"white\", size = 0.2) + \n  geom_sf(data = ev_sf, aes(size = count), color = 'cornflowerblue', alpha = 0.5) +\n  geom_sf(data = urban_poly, aes(fill = \"Urban Areas\"), color = \"pink\", alpha = 0.3) +\n  scale_size_continuous(name = \"EV Registrations\", range = c(1, 12)) +\n  scale_fill_manual(name = \"Legend\", values = c(\"Urban Areas\" = \"pink\")) +\n  labs(\n    title = \"Distribution of EV registrations in WA\",\n    subtitle = \"urban areas\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16),\n    plot.subtitle = element_text(hjust = 0.5, size = 12)\n  )\n\n# ggsave(\"image/manu-urb-ev.png\", plot = urb_map)\nurb_map\n```\n\nAt this stage, we are led to understand the concentration of EV registrations at certain areas, or the attribute similarity of EV counts and their spatial similarity, by suggesting relationships between EV adoption, urban areas and population.\n\n![](image/manu-urb-ev.png)\n\nUsing the definition provided by US Census Bureau, we can assign urban or rural labels to each registration. We learn from this classification that 180,490 registrations took place in urban areas, leaving 27,512 in rural areas. This spatial unevenness is evident when we impose the polygons of urban areas onto the EV population distribution.\n\n### Spatial Autocorrelation\n\nAside from descriptive statistics and mapping, if we seek a more analytical language for communicating our EDA insights, one common approach is to measure spatial autocorrelation for our data.\n\n#### Global moran's I: Clustering of EV registrations\n\nFirstly, we are interested in measuring the autocorrelation of the whole mapped pattern. The way we determine whether our observed point pattern stands out, is to make comparison with the pattern out of complete spatial randomness. The Global Moran's I statistic offers us a way to measures the autocorrelation of the entire observations.\n\nTo estimate the autocorrelation value for our observations using Moran's I formula, we have to specify our statistic of interest, choose a neighbor definition, prepare a neighborhood relation and assign weights to neighbors.\n\nfunction `compute_moran`\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ncompute_moran <- function(nb, listw, poly_sf){\n  n <- length(nb)\n  S0 <- Szero(listw)\n  x <- poly_sf$n_ev\n  moran_result <- spdep::moran(x, listw, n, S0)\n  return(moran_result)\n}\n```\n:::\n\n\n\n\n\n\nWe tried two ways to use `spdep::moran` for calculating Global Moran's I. The step we take her is to aggregate observed points into polygons, ZIP Code Tabulation Areas which contain 605 polygons, and Census Tracts of 1784 polygons, are two targets of aggregation.^[The reason that I did not simply use ZCTAs is although the codebook describes the location variable as the center of postal code areas, but the provided longitude and latitude did not align well with the centroids of ZCTAs from tiger/line shapefile, with cases that more than one points fell within a single ZCTA] When constructing the neighborhood relationships, both Rook and Queen defintions of neighbors are tried, and we used the default setting to assign equal weight to all neighbors. Both attempts are to result in a postive autocorrelation of our observations, pointing us in the direction of non-random spatial clustering. \n\nHowever, the positivity of this autocorrelation value is not that fruitful on its own. For us to reject CSR or to make sense of the significance of our observed Moran's I statistic, we further did a permutation test using `spdep::moran.mc()` and obtained a pseudo p-value of 0.001. Since this is the most extreme value we can get in the case of 999 Monte Carlo Simulations, the likelihood that we reject CSR while CSR is true is a low one. Given a positive and significant global moran's I, we can say that our observe point pattern differs significantly from a random point pattern in the direction of clustering.[@rconsortiumAnalyzingGeospatialData2022]\n\n##### Moran's I using ZCTAs as bounding polygons and Queen Definition of Neighbors\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nzcta_sf <- zcta_sf |> to_4326()\nzcta_intersects <- sf::st_intersects(zcta_sf, ev_counts)\nsum_evs <- function(i) {\n  if (length(i) != 0) {\n    sum_count <- sum(ev_counts$count[i])\n    return(sum_count)\n  }\n  else{\n    return(0)\n  }\n}\n\nnum_ev <- sapply(zcta_intersects, sum_evs)\n# num_ev |> sum()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nzcta_sf <- zcta_sf |> mutate(n_ev = num_ev)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nzcta_nb <- zcta_sf |> spdep::poly2nb()    # default snap = 1e-7\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning in spdep::poly2nb(zcta_sf): some observations have no neighbours;\nif this seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning in spdep::poly2nb(zcta_sf): neighbour object has 5 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nzcta_listw <- zcta_nb |> spdep::nb2listw(zero.policy = TRUE)\nzcta_result <- compute_moran(zcta_nb, zcta_listw, zcta_sf)\nzcta_result[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6457255\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nzcta_mc <- moran.mc(zcta_sf$n_ev, zcta_listw, nsim = 999, alternative = 'greater')\nzcta_mc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  zcta_sf$n_ev \nweights: zcta_listw  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.64146, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nzcta_mc |> plot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n##### Moran's I using Census Tracts as bounding polygons and Rook definition of neighbors\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nev_byct <- ev_sf |> group_by(fips) |> summarize(n_ev = n()) |> ungroup()\nct_sf <- ct_sf |> left_join(st_drop_geometry(ev_byct), by = 'fips') |> mutate(n_ev = replace_na(n_ev, 0))\n\nct_sf$n_ev |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 208002\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_nb <- ct_sf |> spdep::poly2nb(queen = FALSE)\nct_listw <- ct_nb |> spdep::nb2listw(zero.policy = TRUE)\n# print(ct_nb)\n```\n:::\n\n\n\n\n\n\nMoran's I value\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_result <- compute_moran(ct_nb, ct_listw, ct_sf)\nct_result[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5136527\n```\n\n\n:::\n:::\n\n\n\n\n\n##### visualize neiborhood relation\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_nb_cents <- ct_sf |> st_drop_geometry() |> sf::st_as_sf(coords = c(\"INTPTLON20\", \"INTPTLAT20\"), crs = 4326)\n\nct_nb_lines <- ct_nb |> spdep::nb2lines(coords=st_coordinates(ct_nb_cents), as_sf=TRUE)\n\n# mapview(ct_nb_cents) + mapview(ct_nb_lines)\n# from w5\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_mc <- moran.mc(ct_sf$n_ev, ct_listw, nsim = 999, alternative = 'greater')\nct_mc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  ct_sf$n_ev \nweights: ct_listw  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.51365, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_mc |> plot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n#### Local Moran's I: detecting clusters\n\nWith evidence of clustering globally, we also want information about where we can find the clusters. In this case, `spdep::localmoran` can help use with a Moran's I statistic for each census tract.[@geodasoftwareWeek6aLISA2021]\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nev_ct_localmoran <- spdep::localmoran(\n  ct_sf$n_ev,\n  ct_listw)\nev_ct_localmoran |> class()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"localmoran\" \"matrix\"     \"array\"     \n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nev_ct_localmoran |> dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1784    5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_local_df <- as_tibble(ev_ct_localmoran)\ncolnames(ct_local_df) <- c(\n  'local_i', \n  'local_e',\n  'local_var',\n  'local_sd',\n  'local_p'\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_sf7 <- ct_sf |> bind_cols(ct_local_df)\nct_sf7 |> dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1784   26\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nct_local_df$local_i |> as.numeric() |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-2.28334  0.03044  0.19644  0.51365  0.46033 26.79675 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n```{.r}\nev_ct_local <- ct_sf7 |> ggplot() +\n  geom_sf(aes(fill= as.numeric(local_i))) +\n  labs(\n    title = \"Local moran's I by Census Tracts\",\n    fill = \"local_i\"\n  ) +\n  scale_fill_gradient2(low=\"darkblue\", high=\"red\",\n  transform = \"pseudo_log\")\n# +\n  scale_fill_viridis_c(na.value = \"gray\")\n# ggsave('image/ct_localmoran.png', ev_ct_local)\nev_ct_local\n```\n\n![](image/ct_localmoran.png)\n\nLocal Moran's I significance map\n\n```{.r}\nev_ct_local_p <- ct_sf7 |> ggplot() +\n  geom_sf(aes(fill= as.numeric(local_p))) +\n  labs(\n    title = \"Local moran's I by Census Tracts\",\n    fill = \"local_p\"\n  ) +\n  scale_fill_gradient2(low=\"darkred\", high=\"blue\", midpoint=0.1)\n# +\n  scale_fill_viridis_c(na.value = \"gray\")\n# ggsave('image/ct_localmoran_p.png', ev_ct_local_p)\nev_ct_local_p\n```\n\n![](image/ct_localmoran_p.png)\n\n##### local moran permutation test\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_localmoran_perm <- spdep::localmoran_perm(\n  ct_sf$n_ev,\n  ct_listw,\n  nsim = 999,\n  iseed = 6805\n  )\nct_localmoran_perm |> class()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"localmoran\" \"matrix\"     \"array\"     \n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nct_localmoran_perm |> dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1784    9\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_localmoran_perm |> head(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Ii          E.Ii       Var.Ii       Z.Ii Pr(z != E(Ii))\n1 -0.19651842 -0.0031906570 6.079843e-02 -0.7840577      0.4330062\n2  0.00244076  0.0005481923 6.916542e-05  0.2275657      0.8199839\n  Pr(z != E(Ii)) Sim Pr(folded) Sim  Skewness Kurtosis\n1              0.406          0.203  2.272828 12.18684\n2              0.934          0.467 -2.498880 18.68960\n```\n\n\n:::\n:::\n\n\n\n\n\n\nFrom the conditional permutation test, we can plot local significance map and specify different types of associations. The table below is a count table for a Moran scatter plot, we can see that among 521 census tracts with significant pseudo p-values 306 census tracts exhibit Low-Low associations, 205 census tracts for High-High associations. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nsign_factor <- hotspot(\n  ct_localmoran_perm,\n  Prname=\"Pr(z != E(Ii)) Sim\",\n  cutoff=0.05,\n  p.adjust=\"none\"\n  )\ntable(addNA(sign_factor))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  Low-Low  High-Low  Low-High High-High      <NA> \n      306         8        15       205      1250 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_sf7$scatter <- sign_factor\n```\n:::\n\n\n\n\n\n\nLISA Cluster Map\n\n```{.r}\nlocal_perm_map <- ct_sf7 |> ggplot() +\ngeom_sf(aes(fill = scatter)) +\nlabs(\n  title = \"LISA Cluster Map\",\n  fill = \"locations\"\n) +\nscale_fill_manual(\n  values = c(\n    'High-High' = 'red',\n    'High-Low' = 'pink',\n    'Low-High' = 'lightblue',\n    'Low-Low' = 'blue'\n  ),\n  na.value = 'white'\n)\nlocal_perm_map\n# ggsave('image/manu-lisa-cluster.png', local_perm_map)\n```\n\n![](image/manu-lisa-cluster.png)\n\nLocal Moran's I, pseudo p-values from conditional permutation test, and identification of the association types for the significant census tracts, take us to a more in depth understanding of our EV point pattern. Insight into the hotspots and coldspots of EV\nadoption, corresponding to High-High census tracts and Low-Low census tracts is especially helpful because we are inclined to see the hotspots but ignore the coldspots. The LISA Cluster Map reveals to us the clusters centered census tracts with low EV population itself and also surrounded by neighbors with low EV population, this finding is hardly possible to get if we only have the positive cases, or already EV owning househols to visualize. One important aspect of interpreting positive spatial autocorrelation is demonstrated here, we need to think of the bigger picture of clustering as the contribution of attribute, in our case EV count similarity and locational similarity, thus, we won't ignore clusters that have similar low EV counts also have a role to play in this picture. \n\n## Hypothesis Testing\n\nThis section attempts to deal with another aspect we need to account for when acquiring a positive and significant global autocorrelation value for our point pattern of interest. In our case, we want to evaluate how the spatial inhomogeneity of the Washington state can explain for our initial evidence of clustering.\n\nWe want to understand the first-order properties of EV adoption pattern with the awareness of the underlying landscape of the state they have an effect on the adoption potential of different locations. We can take a look at our EV population distribution together with the human population distribution in WA. They appeared to follow very similar distribution, and we do recognize that the core of the definition of an urban area is the spatial distribution of population. \n\nThus, it will be helpful to set aside other characteristics we associate with the urban label at the time, examine the relationship between the two populations in WA. We expect a better understanding of this relationship can guide us to explore to which extent that the EV counts variations across locations can be explained by the population count variations, and how population distribution as a explanation can have different degrees of effectiveness from one region to another.\n\n```{.r}\ndistribution_map <- ggplot() +\n  geom_sf(data = ct_sf, fill = \"lightgray\", color = \"white\", size = 0.2) + \n  geom_sf(\n    data = ev_sf,\n    aes(size = count,\n    color = cb_palette[5]),\n    alpha = 0.6) +\n    scale_size_continuous(name = \"EV Registrations\", range = c(0.1, 15)) + \n    labs(\n    title = \"Distribution of ZEVs in WA\",\n    subtitle = \"Cumulative data to October 31, 2024\",\n    x = \"longitude\",\n    y = \"latitude\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 14),\n    plot.subtitle = element_text(hjust = 0.5, size = 11)\n  ) +\n  guides(color = \"none\")\n\nggsave(\"image/manu-ev-distribution.png\", plot = distribution_map)\n\ndistribution_map\n```\n![](image/manu-ev-distribution.png)\n\nNASA GPW data provides us a glimpse of disaggregated human population data, modeling a human population count for each 1 km^2 grid. We can take it conveniently as a way to make sense of what population point pattern can look like.^[Center for International Earth Science Information Network - CIESIN - Columbia University (2018). Gridded Population of the World, Version 4 (GPWv4): Population Count Adjusted to Match 2015 Revision of UN WPP Country Totals, Revision 11. Palisades, NY: NASA Socioeconomic Data and Applications Center (SEDAC). doi: 10.7927/H4PN93PB. Accessed December 4, 2024.][@ciesin2018gpw]\n\n`gpw_raster`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nprint(gpw_raster)  # single RasterLayer grid dimensions : 416, 955, 397280  (nrow, ncol, ncell)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass      : RasterLayer \ndimensions : 416, 955, 397280  (nrow, ncol, ncell)\nresolution : 0.008333333, 0.008333333  (x, y)\nextent     : -124.8667, -116.9083, 45.54167, 49.00833  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : gpw-popcount.tif \nnames      : gpw.popcount \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ngpw_poly <- gpw_raster |> raster::rasterToPolygons(n = 8, na.rm = TRUE) \n# adjust n: n: integer. The number of nodes for each polygon. \n# Only 4, 8, and 16 are allowed\npopcount_sf <- sf::st_as_sf(gpw_poly)\n# head(popcount_sf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\npopcount_sf |> dim() # 304514      2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 304514      2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# popcount_sf$gpw.popcount |> summary()\npopcount_sf <- popcount_sf |> mutate(pop = `gpw.popcount`)\npopcount_sf$pop |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n   0.000    0.000    0.144   24.585    1.504 7425.167 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n```{.r}\ngpw_map <- popcount_sf |> ggplot(aes(fill = pop)) +\n  geom_sf(color = scales::alpha(\"white\",0)) +\n  scale_fill_viridis_c(trans = 'pseudo_log') + \n  theme_minimal() +\n  labs(\n    title = \"Population Counts in WA\",\n    subtitle = 'GPW V.4 2020-07-01',\n    fill = \"Population Count\"\n    ) + \n  theme(\n    plot.title = element_text(hjust=0.5),\n    plot.subtitle = element_text(hjust=0.5)\n    )\n\nggsave('image/manu-gpw-raster.png', plot = gpw_map)\n\ngpw_map\n```\n```{.r}\nun_map <- popcount_sf |> ggplot(aes(fill = pop)) +\n  geom_sf(color = NA) + \n  scale_fill_viridis(option = 'C', trans = 'pseudo_log') + \n  theme_minimal() +\n  labs(\n    title = 'Population Count',\n    subtitle = 'GPW V.4 2020-07-01',\n    fill = 'Population Count'\n    )\n\nggsave('image/manu-gpw-0701.png', plot = un_map)\nun_map\n```\n![](image/manu-gpw-0701.png)\n\nOur null hypothesis is: the observed EV point pattern can be directly explained by the population distribution of WA. In other words, people in WA have equal chance to adopt EV regardless of where they live, rural or urban and also regardless of whether their neighbors own EVs or not.\n\n### First order properties of point process\n\n#### Intensity Function\n\nOne important limitation of this analysis that needs to be addressed is that we use the WA state boundaries as our observation window. The drawback of this choice is quite obvious: among the three major metropolitan areas in WA, two are situated at the borders of the state -- one with Oregon and the other with Idaho. This can lead to underestimations, as they can have less neighbors as the result of this bounding box.\n\nIntensity function we are interested here is the count of event: count of EVs and count of people in an area\n\nConstructing the `ppp` object for estimating EV population intensity is a more straightforward one, we use the 548 distinct points and marked them with EV registration counts. When it comes to finding an appropriate way to estimate human population intensity, since ZCTAs are not a typical statistical division of US Census Bureau, thus, one way to approach this problem is to use the data of population counts by census tract and use the centroids of the census tracts to construct `ppp` object. Another way we explored is to take the 605 centroids of ZCTAs and request points estimate of population counts also from NASA APPEEARs.[@ciesin2018gpw]\n\nWith these ppps at hand `spatstat::density()` can handle these marked ppp and estimate us the intensity function accounting the marks as weights.\n\n##### `zev_ppp`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nev_counts <- ev_counts |> dplyr::select(count)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# ***\ntr_counts_sf <- ev_counts |> sf::st_transform(3857)\nwa_poly <- wa_poly |> sf::st_transform(3857)\nzev_ppp <- as.ppp(\n  tr_counts_sf,\n  W = as.owin(wa_poly)\n)\n\nzev_ppp$marks <- ev_counts$count\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nzev_int <- density(zev_ppp, weights = zev_ppp$marks, eps = 800)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nplot(zev_int)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nzev_bw <- attr(density(zev_ppp), \"sigma\")\nzev_bw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 70971.96\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\n# intensity values at = 'points'\nzev_int_v <- zev_ppp |> density(\n  weights = zev_ppp$marks,\n  eps = 800,\n  at='points',\n  sigma = zev_bw\n  )\nzev_int_v[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.490786e-07\n```\n\n\n:::\n:::\n\n\n\n\n\n\n##### `pop_int`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfips_centroid_sf <- fips_df |> sf::st_as_sf(\n  coords = c(\"INTPTLON20\", \"INTPTLAT20\"),\n  crs = 4326\n  )\npop_sf <- fips_centroid_sf |> dplyr::select(DP1_0001C)\npop_ppp <- pop_sf |> sf_to_ppp()\npop_ppp$marks <- pop_sf$DP1_0001C\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\npop_ppp$marks |> sum()    # 7705281\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7705281\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\npop_int <- pop_ppp |> density(\n  weights = pop_ppp$marks,\n  eps = 800\n  )\nplot(pop_int)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\n\n\n\n```{.r}\n# png('image/manu-ct-ratio.png', width = 750, height = 500)\nrelative_int(zev_ppp, pop_ppp)\n# dev.off()\n```\n![](image/manu-ct-ratio.png)\n\n\nWith these ppps at hand `spatstat::density()` can handle these marked ppp and estimate us the intensity function accounting the marks as weights.\n\n##### `gpw_ppp`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# gpw_zpts_df$Date |> summary() # 2020-07-01\nzpts_sf <- gpw_pts_df |> sf::st_as_sf(\n  coords = c('Longitude', 'Latitude'),\n  crs = 4326\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nzpts_sf <- zpts_sf |> mutate(\n  pop_count = `GPW_UN_Adj_PopCount_411_population-count`\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# zpts_sf$pop_count |> sum() # 308385.8\n# mapview(zpts_sf, zcol = 'pop_count', label = 'pop_count')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ngpw_sf <- zpts_sf |> dplyr::select(pop_count) |> sf::st_transform(3857)\nwa_poly <- wa_poly |> sf::st_transform(3857)\ngpw_ppp <- as.ppp(\n  gpw_sf,\n  W = as.owin(wa_poly)\n)\nplot(gpw_ppp)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ngpw_ppp$marks |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 308385.8\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ngpw_int <- gpw_ppp |> density(weights = gpw_ppp$marks, eps = 800)\ngpw_int |> plot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n```{.r}\n# png('image/manu-zpts-ratio.png', width = 750, height = 500)\nrelative_int(zev_ppp, gpw_ppp)\n# dev.off()\n```\n![](image/manu-zpts-ratio.png)\n\n#### Relative Intensity Surface\n\nWe use the optimal bandwidths given by spatstat and make adjustments to calculate intensity ratios between our case point pattern to the base rate point pattern. By eliminating the effect of the human population intensity of WA, the relative intensity surface plots still exhibit uneven ratio from location to location suggesting us that point pattern of EV population is a special one.^[the interpretation of the ratio values have things to do with the different number of points between ppp objects, but the color variances is interpretable]\n\n\n#### Monte Carlo Simulation\n\nWe deploy quadrat count to understand how intensity varies from dividing the state in to equal regions of \"Low\", \"Medium\" and \"High\" population. Two intensity functions constructed by Census tract level population count and GPW population count are used as the null point process in the Monte Carlo simulation.\n\n##### divide regions for quadrat count\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nn_regions <- 3\nregion_labels <- c(\"Low\", \"Medium\", \"High\")\npop_vals <- pop_int\npop_quant <- quantile(pop_vals, probs = ((0:n_regions) / n_regions), na.rm = TRUE)\npop_cut <- cut(pop_vals, breaks = pop_quant, labels = region_labels)\n\npop_areas <- tess(image = pop_cut)\nplot(pop_areas)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n##### computational approach: 999 simulations\n\n```{.r}\nset.seed(6805)\ngen_sims_ppp <- function(num_sims = 999) {\n  ev_sims <- spatstat.random::rpoint(\n    n = nrow(ev_sf),\n    f = pop_int,\n    nsim = num_sims\n    )\n  return(ev_sims)\n}\nn_sims <- 999\nev_sims_list <- gen_sims_ppp()\n```\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ncompute_quadrat_counts <- function(sim_ppp) {\n  counts <- quadratcount(\n    sim_ppp,\n    tess = pop_areas\n    ) |> as.vector()\n  names(counts) <- region_labels\n\n  return(counts)\n}\n```\n:::\n\n\n\n\n\n\n##### calculate test statistic from observations\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nev_ppp <- ev_sf |> sf_to_ppp()\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: data contain duplicated points\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nobs_counts <- compute_quadrat_counts(ev_ppp)\nobs_counts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Low Medium   High \n  1644   9001 197357 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n##### calculate test statistic from simulations\n```{.r}\nsims_region_counts <- lapply(\n  X = ev_sims_list,\n  FUN = compute_quadrat_counts\n)\nsim_counts_df <- as_tibble(sims_region_counts) |> t() |> as_tibble()\ncolnames(sim_counts_df) <- region_labels\nsim_counts_df |> head(4)\n```\n```{.r}\nbind_df <- bind_rows(sim_counts_df, obs_counts)\nbind_df |> dim()\nbind_df |> write_csv('data/manu-simulations.csv')\n```\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nbind_df <- read_csv('data/manu-simulations.csv')\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nRows: 1000 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (3): Low, Medium, High\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nsimulations_plot <- bind_df |> ggplot(aes(x=High)) +\n  geom_density(fill=cb_palette[2], alpha=0.5) +\n  geom_vline(xintercept = obs_counts['High'], linetype=\"dashed\", color=cb_palette[1]) + \n  theme_classic()\n\n# ggsave(\"image/manu-sims-distribution.png\", plot = simulations_plot, width = 14, height = 6)\nsimulations_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n```{.r}\nmc_sim <- function(im,fpath1, fpath2, num_sims = 999){\n  n_regions <- 3\n  region_labels <- c(\"Low\", \"Medium\", \"High\")\n  int_vals <- im\n  int_quant <- quantile(int_vals,probs = ((0:n_regions) / n_regions), na.rm = TRUE)\n  int_cut <- cut(int_vals, breaks = int_quant, labels = region_labels)\n\n  int_areas <- tess(image = int_cut)\n  plot(int_areas)\n\n  set.seed(6805)\n  gen_sims_ppp <- function(num_sims) {\n    spatstat.random::rpoint(\n      n = nrow(ev_sf),\n      f = im,\n      nsim = num_sims)\n  }\n  \n  sims_list <- gen_sims_ppp(num_sims)\n\n  compute_quadrat_counts <- function(sim_ppp) {\n    counts <- quadratcount(sim_ppp, tess = int_areas) |> as.vector()\n    names(counts) <- region_labels\n    return(counts)\n  }\n\n  ev_ppp <- sf_to_ppp(ev_sf)\n  obs <- compute_quadrat_counts(ev_ppp)\n\n  sims_region_counts <- lapply(\n    X = ev_sims_list,\n    FUN = compute_quadrat_counts\n    )\n  sim_counts_df <- as_tibble(sims_region_counts) |> t() |> as_tibble()\n  colnames(sim_counts_df) <- region_labels\n\n  bind_df <- bind_rows(sim_counts_df, obs_counts)\n  bind_df |> write_csv(fpath1)\n\n  sims_plot <- bind_df |> \n    ggplot(aes(x = High)) +\n    geom_density(fill = cb_palette[2], alpha = 0.5) +\n    geom_vline(\n      xintercept = obs['High'],\n      linetype = \"dashed\",\n      color = cb_palette[1]\n      ) + \n    theme_classic()\n\n  ggsave(fpath2, plot = sims_plot, width = 14, height = 6)\n  \n  return(sims_plot)\n}\n```\n```{.r}\nmc_sim(gpw_int, 'data/gpw-sims.csv', 'image/gpw-distribution.png')\n```\n\n![](image/gpw-distribution.png)\n\nThe computational approach gives us an entire distribution of our statistics of interest, under the simulations of distributing 208002 EV registrations by human population point process. Given that the observed value lies on the far right tail of the distribution, the likelihood for us to observe 197,900 EV registrations in high population regions is a very low one. Therefore, we can believe that the null hypothesis is not likely to stand. \n\nThe significance of our observed statistics in high population areas is more like a general picture that justifies our attentions to the spatial phenomenon of EVs, however, the findings from LISA Cluster Map from the relative intensity ratio do ask us to pay attention to local differences and how these local differences can contribute to the characteristics of the whole point pattern.\n\n## Discussion\n\nWith the evidence of clustering and after extracting the effect of population intensity, we have evidence to describe EV population point pattern in WA as a whole spatially clustering, and to think about the implications of this overall unevenness. At the same time, the local perspective offers insights into the relationship between attributes and locations in significant clusters. \n\nKnowing the adoption pattern and characteristics of those who already owns an EV might be a way of analyzing the issue of electric vehicle, if the aim of the issue is to anticipate a wider adoption and to eliminate the inequality, getting the glimpse of Low-Low clusters in many ways can be even more insightful. Another way to think of this issue is that of EV owning households today assumingly already have a positive view on EV and they made the decision of buying an EV rationally after evaluating their own living circumstances. Thus, to promote a more positive and decent view on electric vehicles and to prepare a more friendly environment that can support EV purchases, it is evident that more efforts should be made for the Low-Low clusters.\n\n\n## Conclusion\n\nOne perspective confirmed by this project is that, it is actually not that hard to discover EV hotspots, we can find them generally in the urban areas or metro areas, though they may have different degrees of concentration. For example, the heart of Seattle Metro area, census tracts in King County out-performed both the CRS distribution and population distribution. In the case of Clark county and Spokane city, the results are less significant, however, may be due to the effect of the observation window.\nOn the other hand, detecting coldspots requires many more steps, and we tend to underestimate the contribution of local Low-Low clusters to the global clusterness. But coldspots are indeed part of--and might be the essence of--the inequality behind the uneven spatial pattern of EV adoption.\n\nMost of the analysis in this project is at the exploratory stage. As the last section of the project, we are to think about where the EDA result can take us. \n\nTwo of the main reason that people usually give for not considering an EV are: EVs are not affordable, and that EVs are not reliable in terms of the lack of access to charging equipment. [@kikuchi310Americans2024]\n\nIncome and charging station accessibility, at a glance are both following spatial distributions similar toEV population and urban-rural divisions. Research on EVs has devoted much efforts carrying out the message that, with possible rebates to make the upfront cost of purchasing an EV less burdensome, EVs can, in the long term, save commuters more money than petro and diesel cars. As for the range anxiety, which is more expressed by potential EV owners than by actual EV owners, it is explained by that most recent EV owners charge their vehicles at home on daily bases. This implies that they have private parking spaces, can afford to install home charging equipment, and the electric range of their EVs is just sufficient for their daily commute distances. [@AlternativeFuelsDatag]\n\nBut these facts of today are not there to convince us that affordability and public charging infrastructure don't really matter much in the decision of buying an EV. Instead, they can lead us to see that the diffusion of EVs at a stage where barriers between owners and potential owners are not only material but also in knowledge.\n\nLooking forward to the 2030 ZEV mandate, all newly sold vehicles electric, one solution is to make the most of EV charging station. An analysis by Pew Research Center offers an interesting way to think about public charging stations.[@shahElectricVehicleCharging2024] Or, people need to see charging stations for they to develop confidence in EV before they really use them or even before people actually own an EV.\n\nAddressing the unevenness of adoption and the importance of the visibility of EV charging station in the EV diffusion process, can be seen in how Induction Reduction Act incentives target EV charging stations in rural areas, and in reseach exploring models to determine the optimal locations for EV charging station installations. [@trancik16potential]\n\nThe following note is an attempt to take the previous approaches, but this time analyzing the distribution of EV charging station. Some early findings from the relative intensity ratio of charging stations on EV registrations are that the charging station distribution is somewhat more even compared to the EV registrations.\n\n::: {.callout-note appearance=\"simple\" collapse=\"true\" title =\"Distribution of Public Charging Stations in WA\"}\n\n```{.python}\nimport requests\n\napi_key = AFDCKEY\n\nurl = f'https://developer.nrel.gov/api/alt-fuel-stations/v1.csv?api_key={api_key}&fuel_type=ELEC&state=WA&access=public'\noutput_file = 'data/ev_charging_stations_wa.csv'\nresponse = requests.get(url)\nif response.status_code == 200:\n    with open(output_file, 'wb') as f:\n        f.write(response.content)\n    print(f\"{output_file}\")\nelse:\n    print(f\"status code {response.status_code}: {response.text}\")\n\n```\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nstation_df <- read_csv('data/ev_charging_stations_wa.csv')\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nRows: 2662 Columns: 75\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (26): Fuel Type Code, Station Name, Street Address, Intersection Direct...\ndbl   (7): ZIP, EV Level1 EVSE Num, EV Level2 EVSE Num, EV DC Fast Count, La...\nlgl  (39): Plus4, BD Blends, NG Fill Type Code, NG PSI, EV Other Info, Feder...\ndate  (3): Expected Date, Date Last Confirmed, Open Date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\n# station_df |> colnames()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nstation_df <- station_df |> dplyr::select(`Station Name`, `City`, `ZIP`, `EV Level1 EVSE Num`, `EV Level2 EVSE Num`, `EV DC Fast Count`, `Latitude`, `Longitude`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nevse_sf <- station_df |> sf::st_as_sf(\n  coords = c(\"Longitude\", \"Latitude\"),\n  crs = 4326\n)\n# mapview(evse_sf)\n```\n:::\n\n\n\n\n\n![](image/manu-urb-stations.png)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# evse_sf |> sf::st_write('evse.gpkg')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nevse_sf <- sf::st_read('data/evse.gpkg')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `evse' from data source `/Users/toyuan/24-manuscript/data/evse.gpkg' using driver `GPKG'\nSimple feature collection with 2662 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -124.6629 ymin: 45.56257 xmax: -117.0435 ymax: 48.99526\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nstation_counts <- evse_sf |> group_by(geom) |> summarize(count = n())\nstation_counts |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            geom          count      \n POINT        :2647   Min.   :1.000  \n epsg:4326    :   0   1st Qu.:1.000  \n +proj=long...:   0   Median :1.000  \n                      Mean   :1.006  \n                      3rd Qu.:1.000  \n                      Max.   :2.000  \n```\n\n\n:::\n:::\n\n\n\n\n\n\n```{.r}\nurb_station_map <- ggplot() +\n  geom_sf(data = ct_sf, fill = \"lightgray\", color = \"white\", size = 0.2) + \n  geom_sf(data = wa_stations_sf, color = cb_palette[3], alpha = 0.6) +\n  geom_sf(data = to_4326(urban_poly), aes(fill = \"Urban Areas\"), color = \"pink\", alpha = 0.3) +\n  scale_fill_manual(name = \"Legend\", values = c(\"Urban Areas\" = \"pink\")) +\n  labs(\n    title = \"Distribution of Public EV Charging Stations in WA\",\n    subtitle = \"urban areas\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16),\n    plot.subtitle = element_text(hjust = 0.5, size = 12)\n  )\n\nggsave(\"image/manu-urb-stations.png\", plot = urb_station_map)\nurb_station_map\n# 4326\n```\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nevse_ppp <- evse_sf |> sf_to_ppp() |> plot()\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: data contain duplicated points\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n`station_ppp`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nstation_ppp <- station_counts |> sf_to_ppp()\n# plot(station_ppp)\nstation_ppp$marks <- station_counts$count\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# dup_pts <- duplicated(station_ppp)\n# station_ppp2 <- station_ppp[!dup_pts]\nstation_ppp |> npoints()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2647\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nstation_int <- density(\n  station_ppp,\n  weights = station_ppp$marks,\n  eps = 800\n)\nplot(station_int)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-58-1.png){width=672}\n:::\n:::\n\n\n\n\n\n```{.r}\npng('image/manu-station-ratio.png', width = 750, height = 500)\nrelative_int(station_ppp, zev_ppp)\ndev.off()\n```\n![](image/manu-station-ratio.png)\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nn_regions <- 3\nregion_labels <- c(\"Low\", \"Medium\", \"High\")\nzev_vals <- zev_int\nzev_quant <- quantile(zev_vals, probs = ((0:n_regions) / n_regions), na.rm = TRUE)\nzev_cut <- cut(zev_vals, breaks = zev_quant, labels = region_labels)\n\nzev_areas <- tess(image = zev_cut)\nplot(zev_areas)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-59-1.png){width=672}\n:::\n:::\n\n\n\n\n\n```{.r}\nset.seed(6805)\nevse_sims_ppp <- function(num_sims = 999) {\n  evse_sims <- spatstat.random::rpoint(\n    n = nrow(evse_sf),\n    f = zev_int,\n    nsim = num_sims\n    )\n  return(evse_sims)\n}\nn_sims <- 999\nevse_sims_list <- evse_sims_ppp()\n```\n```{.r}\ncompute_quadrat_counts2 <- function(sim_ppp) {\n  counts <- quadratcount(sim_ppp, tess = zev_areas) |> as.vector()\n  names(counts) <- region_labels\n\n  return(counts)\n}\n```\n```{.r}\nobs_evse <- compute_quadrat_counts2(station_ppp)\nobs_evse\n```\n```{.r}\nsim_evse_counts <- lapply(\n  X = evse_sims_list,\n  FUN = compute_quadrat_counts2\n)\nsim_evse_df <- as_tibble(sim_evse_counts) |> t() |> as_tibble()\ncolnames(sim_evse_df) <- region_labels\nsim_evse_df |> head(4)\n```\n```{.r}\nbind_evse_df <- bind_rows(sim_evse_df, obs_evse)\nbind_evse_df |> dim()\n```\n```{.r}\nevse_sim_plot <- bind_evse_df |>\n  ggplot(aes(x=Medium)) + \n  geom_density(fill=cb_palette[2], alpha = 0.5) +\n  geom_vline(xintercept = obs_evse['Medium'], linetype = 'dashed', color = cb_palette[1]) + \n  theme_classic()\n\nevse_sim_plot\nggsave('image/evse-sims-plot.png', evse_sim_plot)\n```\n\n![](image/evse-sims-plot.png)\n\n\n:::\n\nFor the interpretation of the interesting census tracts we find in the LISA cluster map, there is much to anticipate if domain knowledge of the state and locals is introduced.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}